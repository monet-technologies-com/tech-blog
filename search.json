                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    [{"title":"オンデマンドバス最適化のエッセンス1","url":"/tech-blog/2020/09/22/オンデマンドバス最適化のエッセンス1/","content":"# はじめにシステム部の竹内です。今回の記事では、少し真面目に理論的なことを考えていきたいと思います。MONET ではオンデマンドバスを提供するパッケージを提供していますが、配送の最適化は昔から学術的にも考えられている問題です。今回は理論的に最適化問題を解く流れを見ながら、配送最適化のエッセンスを感じていただければと思います。# 一般的にオンデマンドバスを捉えるまず、そもそも「オンデマンドバスの最適化」とはどんな問題なのでしょうか。最適化問題を理論的に考えるときには、まず、何が事前情報として与えられるのか何を決定するのかどんな観点で決定を評価するのかと言った観点を明らかにする必要があります。今回考えたいオンデマンドバスのシチュエーションでは、例えば、何が事前情報として与えられるのか：バスが何台か存在する一度に運べる乗客の積載容量は決まっている乗客が乗降するための駅が何箇所か存在する駅間には距離が定義される利用希望の乗客が何人か存在する出発駅と到着駅のペア何を決定するのか：乗客が、いつ、どの車に乗るか (配車割当)車が、どのような経路で駅間を移動するか (配送経路)どんな観点で決定を評価するのか：全ての車の配送経路の総和として整理することができます。もちろん、問題の捉え方によっては、他の整理の仕方があります。例えば、乗客が決まった出発駅を持たず、現在地から近ければ近いほど好ましい状況、というシチュエーションも考えられます。ただ、いずれにせよ、最適化を理論的に考える場合には、最低限上記の 3 点を明確に正しく把握しておくことは重要です。# よくある運搬経路最適化問題 (VRP)上記問題の詳細を考える問題として、運搬経路最適化問題 (Vehicle Routing Problem) があります。この問題は、巡回セールスマン問題を複数人で分担して行うことを考える問題になっています。理解しやすい解説として、以下の Qiita 記事がよくまとまっています。運搬経路問題（配送最適化問題，Vehicle Routing Problem) を PuLP で解くVRP の特徴として、全てのバスは車庫から出発して車庫に戻ってくる計画を立てるタイミングで全ての予約が出揃っているなどの問題設定がなされています。こちらも重要なポイントですが、実社会にみられる問題は、既に考えられている問題に帰着できる場合があります。このとき、帰着先の問題において、問題設定にどのような前提があるのかをよく理解しながら帰着させることが重要です。今回の問題を VRP として捉えると、バスはキャパシティを持つ乗客は出発地と目的地を持つという観点から、VRP の派生問題である CVRPPD (Capacitated VRP with Pick-up and Delivery) という問題として捉えることができます。# VRP のソルバー考えている問題が何か有名な問題に帰着できる場合 (今回は VRP)、多くの場合既にソルバー (問題を解くためのプログラム / アルゴリズム) が存在します。今回考えている VRP には、OR-tools という OSS ソルバーが存在しています。こちらのようなソルバーを使うと、CVRPPD をプログラムに落とし込むことができます。つまり、駅や車のキャパシティ、乗客の出発地、目的地などのパラメータを与えることによって、プログラムを用いて最適な配送計画を計算することができます。ただし、利用するソルバーによっては、与えられるパラメータに制限がつく各駅について、高々一人が出発地または目的地に設定する (出発地、目的地の重複がない) 状況しか考えられない駅数などパラメータの数に制限がつく処理時間はソルバー依存と言った問題点が出てくる場合もあります。ここでのポイントとしては、考えている問題の規模によって、ソルバーを選ぶ必要があるパラメータの数、処理時間の要求帰着させた問題によっては、ソルバーにあう形で新たな制限 (仮定) を置かなければならない場合がある何らかの高速なソルバーが存在する場合には、帰着させる問題を工夫して、ソルバーで解きやすい形の問題に帰着させることも考慮するといったものが挙げられます。# 実際のプログラムせっかくなので、OR-tools を使って CVRPPD を解くプログラムをみてみます。結構長々と書いてあって小難しく見えますが、実際このプログラムの重要なところは create_data_model()  の中で、問題のパラメータ (駅の数など) はこちらで指定できます。ここまでできれば、あとはソルバーがよしなに解いてくれます。実行結果としては、として出力されます。このような一連の流れで、最適化問題は実際に解くことができます。一点注意したいのが、ソルバーによっては、導き出される解がグローバルに最適解でない (ちょっと解を弄るだけでは状況を改善できないが、実は全く別の解を持ってくると改善される) 可能性も存在します。グローバルな最適解かどうかは、ソルバーのアルゴリズムに依存するので、どうしてもグローバルな最適解が必要な場合は注意が必要です。ただし、グローバルな最適解が本当に必要か、という観点もまた重要です。例えば、処理時間を 1 日かけて 0.01% 改善する解を得ることは、学術的には意味があるかもしれませんが、実際の社会に組み込む視点で見るとどうでしょう。それよりも、数秒で 90% の結果を得る方が、価値がある場合もありそうです。# まとめ最適化をするときは、問題から与えられる情報と目的、決定する項目を明らかにする有名な問題 / 解きやすい問題に帰着できないか検討問題をプログラムに落とし込んでソルバーに投げる出てきた解を解釈 / 利用するといった流れを組みます。なかなか奥が深いですね。# 終わりに今回は問題を VRP に帰着しましたが、オンデマンドバスのシステム構成によっては、VRP に帰着すると不都合な点もいくつかあります。そのような場合には、VRP に帰着せず、より詳細に問題を定式化する必要があります。そちらは、また他の記事でご紹介できればと思います。","tags":["最適化","VRP"],"categories":["理論考察"]},{"title":"ルート検索OSS (OSRM) の予測精度を調べました (執筆中)","url":"/tech-blog/2020/08/30/ルート検索OSS (OSRM) の予測精度を調べました/","content":"執筆中の記事です (ドラフトです)システム部の登山担当太田です山はいいぞ今回はルート検索のOSSであるOSRMを検証した話です地図データにはOSMを用いています導入は別で書きます前談ルート検索のコスト削減MONETではオンデマンドバスサービスを提供していますがその裏ではルート検索による時間取得のロジックが何度もはしっていますマッチングの最適化など今後進めていくにあたってもルート検索のコストは抑えたいところですそこで信頼性をある程度担保して低コストなルート検索できないかな？ということでOSSの有効性を検証しましたOSMとは素晴らしい取り組みとしてOpen Street Map (OSM) という地理情報をみんなで作って行こうぜ！オープンライセンスで誰にでも使えるようにしようぜ！というイカしたプロジェクトがありますOpen Street Mapでは所々足りていない情報はありますが道路のクラス分けや店舗の情報までオープンライセンスと考えれば十分すぎるほどの地理データが利用できますOSMで利用可能な情報○道路分類, 建物分類, 各名称×公共交通機関, 交通量もちろん自分たちで編集ができ, 自宅の周りとか眺めてポチポチするだけで世界の地理データベース作成に貢献できるのでぜひやってみてください！OSRMとはルート検索エンジンのOSSです.中身のアルゴリズムはmulti dikstraでOSMの地図情報を基に最短ルートを決定します. (他のアルゴリズムも使用可)高速道路を省いたり, Uターンを禁止したりなど痒いところの設定までできてしまう優れものです.Mapboxでも採用されていたりします.ブログ記事ルート検索だけでなくMapBoxでも採用されていたりしますこのルート検索エンジン使ってどれくらい正しく予測できるの？というのが今回のお題ですOSRMってどんな感じで動いてますん実装までは他記事でも紹介されているので省きますがザクっとこんな感じですOSMの最新地図情報を保存luaファイル定義に従って重み付けされたグラフを作成HTTPサーバーを起動してリクエスト検証最初に東京都内の限られた範囲でランダムに2点を限られた範囲でのルート検索制度を検証しました.検証範囲は以下になります.この中で1000回程度Google Direction API, OSRM APIどちらも叩いて統計差がどれくらいか, 変なルート通っていないか比較しました.設定はこんな感じです両方とも高速道路を通らないDirection APIはtrafficMode=optimisticOSRMは交通量情報を考慮しないOSRMの設定luaファイルはデフォルト (car.lua) のまま結果予測結果ランダムに1つ抜き出してきました.ルートは似たようなルートを通っていますが時間が結構ずれています.距離誤差＆時間誤差距離/時間の相対誤差のヒストグラムは以下のようになりました.ルート可視化と同様に, 距離誤差はデフォルトでもある程度正しいですが時間誤差が大きいので修正が必要です.速い道路, 遅い道路の区分け適当に低速, 中速, 高速で分けると高速の比率が大きいほど予測を外していることが分かりました.チューニング上記の結果を踏まえてチューニングを行いました.luaファイル内では道路のタグ名ごとに初期設定速度を入れています.今回はそちらを定数倍する大雑把な修正を行いました.これで統計的な情報をある程度合わせられる！(チューニングですので)チューニング結果こんな感じになりました散布図ヒストグラム平均はあるていど合わせられましたが分散までGoogleの予測と同様とはやはり行かなかったです.交通量の考慮も入ってくるのでそのままの代用は難しいですね.一方, 大きく外すわけではないので裏のロジックに使用したりとか使い道を考えれば導入できるのでは？という感触でしたまとめGoogleと比較して検証しました全体大きくは外さないですがダメな時もありましたどこまでの精度求めるかによりますが存外使えるかもという事で裏側ロジックでの実装と導入どの部分に使うかを模索することになりました.","tags":["OSS","OSM","OSRM"],"categories":["OSS検証"]},{"title":"Arch Linuxはいいぞという話","url":"/tech-blog/2020/08/18/Arch Linuxはいいぞという話/","content":"# はじめにMONET Technologies 株式会社、2020 年新卒入社の竹内です。この記事では、自分のおすすめする　Linux ディストリビューションである Arch Linux についてちょろっと書かせて頂きます。# Arch Linux が好きです。エンジニアなら一度は辿り着く境地、 「オレオレカスタマイズしたマイスイート PC を作りたい」自分はハードウェアがそこそこの PC に、どんなソフトを載せるか、というところが好きです (自作 PC 勢のお話も是非聴いてみたいですが)。そんな自分が大学生の時からお世話になっているのが、Arch Linux という Linux のディストリビューションです。# 何がいいの？めちゃくちゃ軽量 &amp; 爆速 (個人の感想です)パッケージマネージャが優秀 (ほとんどのソフトを一つのパッケージマネージャで完結できて嬉しい)最初にミニマムな要素 (CLI 環境) しか入っていないので、ウィンドウマネージャなどを自分の好みで入れられるこの辺が自分のツボです。特に、高校生の頃に買った弱い PC に Arch を入れた時、あんなに Windows が重かったのが爆速で動くようになった感動を今でも忘れられません。# まぁ諸説あるけどとはいえ、確かに、 少しメンテナンスが面倒くさい こともあるかもしれません。特に、Arch には始め殆どの要素は入っていない状態からスタートするので、デスクトップ環境を構築するまでが面倒だったり、カーネルのアップデートで起動しなくなったり、ということも無くはないです。が、手のかけた子ほど可愛い、そう思いませんか？(個人の意見です)何か問題が起きたとしても、Arch Wiki がかなり優秀なので、大抵なんとかなります。余談ですが、Ubuntu など別の Linux ディストリビューションを使っても Arch Wiki の情報で助かったりするので、優秀なドキュメントになっているなと感じます。# おすすめのウィンドウマネージャせっかくなので、Arch Linux 上での構成を少しだけお話します。自分はウィンドウを画面一杯、もしくは二つのウィンドウを右と左に分けて、と言った感じで敷き詰めるのが好きなので、タイル型のウィンドウマネージャが好きです。自分の PC に入れているのは、awesome というウィンドウマネージャです。こちらを使うと、ショートカットキーでウィンドウの配置フォーカスの切替などが簡単にできるので好みです。さらに、google-chrome の remote desktop も入るので、自宅の PC に Arch Linux を入れて、リモートデスクトップを経由して手元の PC から作業、なんてこともできます。リモートデスクトップの割に爆速で、中でどんな仕組みになっているか気になっちゃいますね。。。# まとめArch Linux はいいぞ。","tags":["Arch Linux","Linux"],"categories":["おすすめ技術"]},{"title":"技術ブログ始めました(VSCodeの設定編)","url":"/tech-blog/2020/07/15/技術ブログ始めました(VSCodeの設定編)/","content":"# はじめにMONET Technologies 株式会社、2020 年新卒入社の竹内です。この記事では、技術ブログ開始に当たって、VSCode での Hexo 記事執筆環境を導入した話です。全体構成のお話は技術ブログ始めました(構成編)でお話しています。静的サイトジェネレータである Hexo を導入したお話は技術ブログ始めました(Hexo-on-Docker編)でお話しています。# 楽な執筆環境に向けて技術ブログ、エンジニアの方なら一度は書こうとするものだと思うのですが、3 ヶ月続けられた方には心からの拍手を送りたいです。やはり、モノを書く、アウトプットするのってコストが高いんですよね。単なるメモ程度なら雑に書いても良いわけですが、ブログとして書こうとするとある程度体裁を整えないといけなかったり。。。といったことを考えると、筆が重くなり。。。そこで今回は、執筆を楽にするためのツール、VSCode 上のエクステンションを紹介してみます。# vscode-hexo-utilsHexo+VSCode で執筆する際には必須のエクステンションです。この vscode-hexo-utils を使うと記事一覧やタグ一覧を表示するサイドバーの追加マークダウンに画像を挿入したプレビュー時、Hexo ならではの画像ディレクトリ構成に対応してプレビューを見せてくれるWin:ctrl-alt-v Mac:opt-cmd-v でクリップボードの画像を貼り付け (記事に対応した画像配置用ディレクトリの作成とマークダウン上の参照文記述)などなどしてくれるので大分執筆が楽になります。特に画像の挿入は重要なので、開発者には頭が上がりません。# Remote Developmentこちらは Docker など、リモートとして作った環境に対して VSCode を接続できるエクステンションです。今回は Docker 上に Hexo や Git を構成しているので、直接接続して、Docker 上のコマンドを呼び出す、なんてことが簡単になります。ただ、残念なことが、 リモートで接続した際にクリップボードが共有化されていないらしく、上記の vscode-hexo-utils の画像コピペ機能が上手く働きません。そのため、こちらは残念ながら、執筆中には使えない感じになっています。。。もしクリップボードの共有化ができると、vscode を直接 Docker に繋げるvscode-hexo-utils を使いながら執筆直接 Docker 内のコマンドを叩いてデプロイといった使い方ができるようになります。もちろん今の Remote Development 機能も大変良いモノで、友人なんかは、RaspberryPi などでリモート環境を作る、VSCode でリモート接続して手元の PC で IoT 開発、なんてこともしているのでおすすめです。# VSCode のタスク機能今回は Docker を通じてのデプロイになりますが、VSCode の方でコマンドを打ってデプロイまで行いたいですよね。そこで使うのが、VSCode のタスク機能です。参考になるのがこちらです。自分はというコマンドを登録して、VSCode から Docker 上の Git を叩き、push するとともにデプロイを行っています。このタスク機能を使えば、任意のコマンドを VSCode 上で使えるので良いですね。# vscode-drawio最後に紹介するエクステンションは、vscode-drawio です。こちらはブラウザ上で動く draw.io を vscode 上で動かそうというモノで、簡単な図を書きたい時に使えます。この、なんでもエディタ上にのせてやろうという心意気、自分は嫌いじゃないです。笑# まとめ様々な VSCode のエクステンションがあって、見ていて楽しいです。もちろんエンジニアは何を生み出すか、も重要ですが、たまには息抜きに自分の道具を磨いて見るのも良いですね。","tags":["hexo","vscode"],"categories":["ブログ環境"]},{"title":"技術ブログ始めました(Hexo-on-Docker編)","url":"/tech-blog/2020/07/15/技術ブログ始めました(Hexo-on-Docker編)/","content":"# はじめにMONET Technologies 株式会社、2020 年新卒入社の竹内です。この記事では、技術ブログ開始に当たって、静的サイトジェネレータ Hexo を導入した話です。全体構成のお話は技術ブログ始めました(構成編)でお話しています。# Docker 使ってみますさて、それでは本題に入っていきましょう。前提として、今回は Hexo 環境を Docker で構築します。Docker 環境自体の構築についてはこちらを参照しました。筆者は今回初めて Docker を使ってみているので、変なところがあれば指摘していただければと思います。流れとしては、執筆用 Docker イメージのビルドDocker コンテナの実行といったところです。# 執筆用 Docker イメージのビルドまず、執筆用の Docker イメージをビルドするところから始まります。Hexo 用の Docker イメージとしてこちらを参考にしました。Dockerfile をお好みに記述したら、記述したファイルの存在するディレクトリ上で、とすれば Docker イメージがビルドされます。上記リンクで紹介した Docker ファイルではHexo 環境の導入デプロイ用 Git の導入 (SSH キーの配置も含めて)まで行ってくれるようになっています。今回は、ブログのソースリポジトリを Github にプッシュGithub Pages の公開用リポジトリを更新という流れを自動化したかったので、Git の hook 機能を使って Hexo のコマンドを紐づけるようにしています。具体的には、Hexo 用のデプロイコマンドを記述したファイル pre_push  を作り、~/.git/hooks/  以下に配置するようにしています。今回は push する前という hook になっていますが、複数人で編集することを考えると、リモートリポジトリでのマージが終わったタイミングの方が良かったかもしれないと思っています。が、今回 Github がリモートリポジトリになっているので、リモートサーバ上での hook が実装できず、ひとまず push をトリガーにしています。Gitlab など自前で Git サーバを立てている際には、ブログを書く時にはまず執筆ブランチを切るブログ執筆後、執筆ブランチ上の変更を pushリモートリポジトリで執筆ブランチをマスターブランチにマージマージ後の hook で公開用リポジトリへソースをデプロイみたいな流れが安全そうです。# Docker コンテナの実行Docker イメージをビルドしたら、でコンテナを作成し開始します。これを行うことで、Docker コンテナ上の Hexo サーバが動き、http://localhost:4000を参照することでローカルなサイトのプレビューができるようになります。# まとめDocker を使うことによって、複数人が使うブログの執筆環境をある程度簡易に構築することができました。便利なツールが増える一方、依存関係などで導入が面倒になることもよくあるので、Docker のようなツールもうまく使えるとよりハッピーになりそうですね。時代の主流は SaaS でローカルに環境を整える場面も少なくなってきそうですが。。。","tags":["hexo"],"categories":["ブログ環境"]},{"title":"技術ブログ始めました(構成編)","url":"/tech-blog/2020/07/14/技術ブログ始めました(構成編)/","content":"# はじめにMONET Technologies 株式会社、2020 年新卒入社の竹内です。この度、弊社でも社員の技術力向上 &amp; アウトプットのために、技術ブログを開設する運びとなりました。記念すべき 1 回目の記事は、この技術ブログの立ち上げについて一通り書きます。# 技術ブログの選定技術ブログを作成するに当たって考えたのは、サーバの維持コスト記事の管理コスト執筆環境の 3 点です。技術ブログを公開するというということは当然 Web サーバが必要になるわけですが、そこにコストやメンテナンスが必要になると継続するのが面倒です。なので、何か外部のサービスを使って公開したいという要求があります。また、ページを編集したら、編集履歴や差分まで管理したいです。更に、執筆環境としては、普段コードを書いたりするエディタを使ってそのまま書きたいですよね。ということで、今回は静的サイトジェネレータ Hexo と Github Pages を使って技術ブログを作ってみることにしました。ただ、今回用いる Hexo は Node.js で作られており、バージョン管理などが面倒です。そこで、今回は、生成環境：Docker 上の Hexo執筆環境：Visual Studio Code などの各自のエディタ公開環境：Github Pagesという構成で全体を組みました (もちろん執筆環境はお好きなエディタを使ってください)。全体構成のイメージはこんな感じです。次回からそれぞれの環境について執筆していきます。# まとめ技術ブログを始めるので皆様ゆるゆるとお付き合いください！","tags":["hexo","vscode","github","docker"],"categories":["ブログ環境"]}]